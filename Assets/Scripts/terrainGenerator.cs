using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class terrainGenerator : MonoBehaviour
{

    //The map that shows the terrain value at each existing coordinate
    private Dictionary<string, terrain> terrainMap;

	/// Size of a section side generated for the map
	private static int chunkSize = 100;
	public static int SEED = 0;
	/*
    //The y size of a generated section of the map
    public int chunkSizeY;
    //The x size of a generated section of the map
    public int chunkSizeX;
	*/

    //A divisor that determines the amount of water generated by the perlin noise function
    public float waterAmount;

    //A divisor that determines amount of specific terrain based on temperature
    public float terrainAmount;

	private float [] thresholds = new float[(int)terrain.GRASS];

    public GameObject Water;

    public GameObject Grass;

    public GameObject Dirt;

    public GameObject Stone;

    public GameObject Snow;

    public GameObject Sand;

    public GameObject Desert;

    //Affects the types of terrain that are generated
    public float terrainSeed;

    public float waterSeed;

    // Enumerate terrain
	private enum terrain {
		WATER,
		DIRT,
		SNOW,
		STONE,
		GRASS,
        SAND,
        DESERT
	}

	private float getThreshold(terrain t){
		switch (t) {
		case terrain.WATER:
			return 0.2f;
        case terrain.SAND:
            return 0.25f;
		case terrain.DIRT:
			return 0.80f;
		case terrain.STONE:
			return 0.90f;
		case terrain.SNOW:
			return 1.0f;
		case terrain.GRASS:
			return 0.65f;
        case terrain.DESERT:
            return 0.30f;
		default:
			return 0.1f;
		}
	}

	private GameObject getObject(terrain t){
		switch (t) {
		case terrain.WATER:
			return Water;
		case terrain.SAND:
			return Sand;
		case terrain.DIRT:
			return Dirt;
		case terrain.STONE:
			return Stone;
		case terrain.SNOW:
			return Snow;
		case terrain.GRASS:
			return Grass;
		case terrain.DESERT:
			return Desert;
		default:
			return Grass;
		}
	}


	float posNoise(int val){
		return (float)val / 20f + SEED;
	}
    // Use this for initialization
    void Start()
	{

		terrainMap = new Dictionary<string, terrain>();
		generateChunk (0,0);

        //System.Random randomNum = new System.Random();
        




    }


	/// <summary>
	/// Generates the chunk at xy chunk position.
	/// </summary>
	/// <returns>The chunk.</returns>
	/// <param name="xPos">X position.</param>
	/// <param name="yPos">Y position.</param>
	GameObject[,] generateChunk(int xPos, int yPos){

		GameObject[,] tempChunk = new GameObject[chunkSize,chunkSize];



		for (int y = 0; y < chunkSize; y++)
		{
			for (int x = 0; x < chunkSize; x++)
			{

				GameObject tempTile;
				float xNoiseValue = posNoise(x);
				float yNoiseValue = posNoise(y);
				//terrainMap.Add(x +" " + y, Mathf.PerlinNoise(xNoiseValue, yNoiseValue)/waterAmount);

				float waterVal = Mathf.PerlinNoise (posNoise (x) + waterSeed, posNoise (y) + waterSeed) / waterAmount;

				float terrainVal = Mathf.PerlinNoise(posNoise(x) + terrainSeed, posNoise(y) + terrainSeed) / terrainAmount;

				// Check if this tile is edited already
				if(terrainMap.ContainsKey("x y"))
				{
					// Instantiate saved game object from terrain
					tempTile = getObject(terrainMap["x y"]);
				}else if (waterVal < getThreshold(terrain.WATER))
				{
					tempTile = Water;
				}else if (waterVal < getThreshold(terrain.SAND))
				{
					tempTile = Sand;
				}

				else
				{
					if (terrainVal <= getThreshold(terrain.DESERT))
					{
						tempTile = Desert;
					}
					else if (getThreshold(terrain.DESERT) < terrainVal && terrainVal <= getThreshold(terrain.GRASS))
					{
						tempTile = Grass;
					}
					else if (getThreshold(terrain.GRASS) < terrainVal && terrainVal <= getThreshold(terrain.DIRT))
					{
						tempTile = Dirt;
					}
					else if (getThreshold(terrain.DIRT) < terrainVal && terrainVal <= getThreshold(terrain.STONE))
					{
						tempTile = Stone;
					}
					else 
					{
						tempTile = Snow;
					}
				}
				tempTile = Instantiate(tempTile, new Vector3(x, y, 0), Quaternion.identity);
				tempChunk [x, y] = tempTile;
			}
		}
		return tempChunk;
	}

    // Update is called once per frame
    void Update()
    {

    }
}
